#!/bin/bash
#
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.
#

#
# Copyright (c) 2014, Joyent, Inc.
#

#
# Build a single node from a given JSON object describing
# build options.
#
# Usage:
#   ./tools/build-a-node BUILD-OPTS BUILD-DIR BUILD-STAMP
#
# Example:
#   ./tools/build-a-node '{"version": "v0.8.23}' \
#       `pwd`/build/nodes/v0.8.23-zone \
#       master-20130913T173257Z-gfb34f86
#
# TODO: document supported build options
# - version:
# - sha: Optional. If given it overrides `version` for the 'git checkout'.
# - configure_flags:
# - build_env: Environment vars to pass to the `make` command to build node
# - build_tag:
# - gcc_version_range: A node-semver range to compare against the GCC used to
#   build node
# - rpath: A string to which to set the node RPATH/RUNPATH.
# - include_gcc_runtime_libs: Include the needed libs from the GCC runtime
#   (/opt/local/lib/gcc$major$minor/...) that are used by the built node.
#   Commonly this is used together with `rpath=$ORIGIN/../lib` to make node
#   able to load those libs.
# - patch_files: Optional. A list of paths (relative to the project root)
#   of patch files to apply.
# - npm_version: Optional. A commitish for a special version of npm to pull in
#   and replace the one include with the given node version.
# - npm_repo: Optional. If `npm_version` is used, this can be set to an alternative
#   git repo (e.g. an npm fork). This is only intended for pre-release experimental
#   builds. The default repo URL is "https://github.com/npm/npm.git"


export PS4='+[\D{%FT%TZ}] ${BASH_SOURCE}:${LINENO}: ${FUNCNAME[0]:+${FUNCNAME[0]}(): }-- '
set -o xtrace
set -o errexit
set -o pipefail

TOP=$(cd $(dirname $0)/../ >/dev/null; pwd)

GCC=/opt/local/bin/gcc
GXX=/opt/local/bin/g++
ELFEDIT=/usr/bin/elfedit

buildOpts=$1
buildDir=$2
buildStamp=$3

echo ""
echo "# Build a node in $buildDir with this config:"
echo "$buildOpts" | json

# Ensure we have a particular gcc version.
gccVersionRange=$(echo "$buildOpts" | json gcc_version_range)
if [[ -n "$gccVersionRange" ]]; then
    currGccVer=$($GCC --version | head -1 | awk '{print $NF}')
    matching=$(./node_modules/.bin/semver -r "$gccVersionRange" $currGccVer || true)
    if [[ -z "$matching" ]]; then
        echo "build-a-node: fatal error: gcc version ($currGccVer) does not" \
            "match the given range: $gccVersionRange" >&2
        exit 1
    fi
fi

if [[ -d $buildDir ]]; then
    rm -rf $buildDir
fi
mkdir -p $buildDir

cp -PR $TOP/build/src $buildDir/src
cd $buildDir/src
version=$(echo "$buildOpts" | json version)
if [[ -z "$version" ]]; then
    echo "build-a-node: fatal error: no 'version' given" >&2
    exit 1
fi
sha=$(echo "$buildOpts" | json sha)
if [[ -n "$sha" ]]; then
    git checkout $sha
else
    git checkout $version
fi

npmVersion=$(echo "$buildOpts" | json npm_version)
if [[ -n "$npmVersion" ]]; then
    npmRepo=$(echo "$buildOpts" | json npm_repo)
    rm -rf deps/npm
    if [[ -n "$npmRepo" ]]; then
        git clone $npmRepo deps/npm
    else
        git clone https://github.com/npm/npm.git deps/npm
    fi
    (cd deps/npm && git checkout $npmVersion)
fi

# Patching
patchFiles=$(echo "$buildOpts" | json patch_files)
if [[ -n "$patchFiles" ]]; then
    numPatchFiles=$(echo "$patchFiles" | json length)
    for (( i=0; i<$numPatchFiles; i++ )); do
        patchFile=$(echo "$patchFiles" | json $i)
        patch -p1 <$TOP/$patchFile
    done
fi

configureFlags=$(echo "$buildOpts" | json configure_flags)
if [[ -z "$configureFlags" ]]; then
    configureFlags="--with-dtrace"
fi
./configure $configureFlags --prefix=$buildDir/node

buildEnv=$(echo "$buildOpts" | json build_env)
make V=1 CC=$GCC CXX=$GXX $buildEnv
make V=1 CC=$GCC CXX=$GXX $buildEnv install

# Optionally include GCC runtime libs. If a version of GCC was used to compile
# node is greater than the version of the GCC runtime libs included in the
# platform *and* this node build is targetted for use in the GZ, then the
# node build needs to (a) include the needed GCC runtime libs and (b) set a
# RUNPATH for the node binary to find them.
#
# See <https://github.com/joyent/rfd/tree/master/rfd/0059#problems-with-the-gz>
# for details.
includeGccRuntimeLibs=$(echo "$buildOpts" | json include_gcc_runtime_libs)
if [[ -n "$includeGccRuntimeLibs" ]]; then
    ldd ./node  | awk '{print $3}' | grep '^/opt/local/gcc' | while read lib; do
        cp $lib $buildDir/node/lib/
    done
fi

rpath=$(echo "$buildOpts" | json rpath)
if [[ -n "$rpath" ]]; then
    $ELFEDIT -e "dyn:runpath $rpath" $buildDir/node/bin/node
fi


# trim
rm -rf $buildDir/node/lib/node_modules/npm/.git

# package
imageUuid=$(echo "$buildOpts" | json image)
buildTag=$(echo "$buildOpts" | json build_tag)
if [[ -n "$buildTag" ]]; then
    buildTag=-$buildTag
fi
cd $buildDir
tar czf sdcnode-$version$buildTag-$imageUuid-$buildStamp.tgz node
